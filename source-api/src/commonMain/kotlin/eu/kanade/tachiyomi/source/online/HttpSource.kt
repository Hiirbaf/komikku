package eu.kanade.tachiyomi.source.online

import android.app.Application
import eu.kanade.tachiyomi.network.AndroidCookieJar
import eu.kanade.tachiyomi.network.GET
import eu.kanade.tachiyomi.network.NetworkHelper
import eu.kanade.tachiyomi.network.asObservableSuccess
import eu.kanade.tachiyomi.network.awaitSuccess
import eu.kanade.tachiyomi.network.newCachelessCallWithProgress
import eu.kanade.tachiyomi.source.CatalogueSource
import eu.kanade.tachiyomi.source.model.AnimesPage
import eu.kanade.tachiyomi.source.model.FilterList
import eu.kanade.tachiyomi.source.model.Video
import eu.kanade.tachiyomi.source.model.SAnime
import eu.kanade.tachiyomi.source.model.SEpisode
import exh.log.maybeInjectEHLogger
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import okhttp3.Headers
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import rx.Observable
import tachiyomi.core.common.util.lang.awaitSingle
import uy.kohesive.injekt.Injekt
import uy.kohesive.injekt.api.get
import java.net.URI
import java.net.URISyntaxException
import java.security.MessageDigest

/**
 * A simple implementation for sources from a website.
 *
 * Supposedly, it expects extensions to overwrite get...() methods while leaving those fetch...() alone.
 * Hence in extensions-lib, it will leave get...() methods as unimplemented
 * and fetch...() as IllegalStateException("Not used").
 *
 * Prior to extensions-lib 1.5, all extensions still using fetch...(). Because of this,
 * in extensions-lib all get...() methods will be implemented as Exception("Stub!") while
 * all fetch...() methods will leave unimplemented.
 * But if we want to migrate extensions to use get...() then those fetch...()
 * should still be implemented as IllegalStateException("Not used").
 */
@Suppress("unused")
abstract class HttpSource : CatalogueSource {

    /**
     * Network service.
     */
    // SY -->
    protected val network: NetworkHelper by lazy {
        val network = Injekt.get<NetworkHelper>()
        object : NetworkHelper(Injekt.get<Application>(), Injekt.get(), network.isDebugBuild) {
            override val client: OkHttpClient
                get() = network.client
                    .newBuilder()
                    .maybeInjectEHLogger()
                    .build()

            @Deprecated("The regular client handles Cloudflare by default")
            override val cloudflareClient: OkHttpClient
                get() = client

            override val cookieJar: AndroidCookieJar
                get() = network.cookieJar
        }
    }
    // SY <--

    /**
     * Base url of the website without the trailing slash, like: http://mysite.com
     */
    abstract val baseUrl: String

    /**
     * Version id used to generate the source id. If the site completely changes and urls are
     * incompatible, you may increase this value and it'll be considered as a new source.
     */
    open val versionId = 1

    /**
     * ID of the source. By default it uses a generated id using the first 16 characters (64 bits)
     * of the MD5 of the string `"${name.lowercase()}/$lang/$versionId"`.
     *
     * The ID is generated by the [generateId] function, which can be reused if needed
     * to generate outdated IDs for cases where the source name or language needs to
     * be changed but migrations can be avoided.
     *
     * Note: the generated ID sets the sign bit to `0`.
     */
    override val id by lazy { generateId(name, lang, versionId) }

    /**
     * Headers used for requests.
     */
    /* SY --> */
    open /* SY <-- */ val headers: Headers by lazy { headersBuilder().build() }

    /**
     * Default network client for doing requests.
     */
    open val client: OkHttpClient
        // SY -->
        get() = network.client
    // SY <--

    /**
     * Generates a unique ID for the source based on the provided [name], [lang] and
     * [versionId]. It will use the first 16 characters (64 bits) of the MD5 of the string
     * `"${name.lowercase()}/$lang/$versionId"`.
     *
     * Note: the generated ID sets the sign bit to `0`.
     *
     * Can be used to generate outdated IDs, such as when the source name or language
     * needs to be changed but migrations can be avoided.
     *
     * @since extensions-lib 1.5
     * @param name [String] the name of the source
     * @param lang [String] the language of the source
     * @param versionId [Int] the version ID of the source
     * @return a unique ID for the source
     */
    @Suppress("MemberVisibilityCanBePrivate")
    protected fun generateId(name: String, lang: String, versionId: Int): Long {
        val key = "${name.lowercase()}/$lang/$versionId"
        val bytes = MessageDigest.getInstance("MD5").digest(key.toByteArray())
        return (0..7).map { bytes[it].toLong() and 0xff shl 8 * (7 - it) }.reduce(Long::or) and Long.MAX_VALUE
    }

    /**
     * Headers builder for requests. Implementations can override this method for custom headers.
     */
    protected open fun headersBuilder() = Headers.Builder().apply {
        add("User-Agent", network.defaultUserAgentProvider())
    }

    /**
     * Visible name of the source.
     */
    override fun toString() = "$name (${lang.uppercase()})"

    /**
     * Get a page with a list of anime.
     * Normally it's not needed to override this method.
     *
     * @since extensions-lib 1.5
     * @param page the page number to retrieve.
     */
    override suspend fun getPopularAnime(page: Int): AnimesPage {
        @Suppress("DEPRECATION")
        return this.fetchPopularAnime(page).awaitSingle()
    }

    /**
     * Returns an observable containing a page with a list of anime.
     * Normally it's not needed to override this method.
     *
     * @param page the page number to retrieve.
     */
    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getPopularAnime(page)"))
    open fun fetchPopularAnime(page: Int): Observable<AnimesPage> {
        return client.newCall(this.popularAnimeRequest(page))
            .asObservableSuccess()
            .map { response ->
                this.popularAnimeParse(response)
            }
    }

    /**
     * Returns the request for the popular anime given the page.
     *
     * @param page the page number to retrieve.
     */
    protected open fun popularAnimeRequest(page: Int): Request = throw UnsupportedOperationException("Unsupported!")

    /**
     * Parses the response from the site and returns a [AnimesPage] object.
     *
     * @param response the response from the site.
     */
    protected open fun popularAnimeParse(response: Response): AnimesPage = throw UnsupportedOperationException("Unsupported!")

    /**
     * Get a page with a list of anime.
     * Normally it's not needed to override this method.
     *
     * @since extensions-lib 1.5
     * @param page the page number to retrieve.
     * @param query the search query.
     * @param filters the list of filters to apply.
     */
    override suspend fun getSearchAnime(page: Int, query: String, filters: FilterList): AnimesPage {
        @Suppress("DEPRECATION")
        return this.fetchSearchAnime(page, query, filters).awaitSingle()
    }

    /**
     * Returns an observable containing a page with a list of anime.
     * Normally it's not needed to override this method.
     *
     * @param page the page number to retrieve.
     * @param query the search query.
     * @param filters the list of filters to apply.
     */
    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getSearchAnime(page, query, filters)"))
    open fun fetchSearchAnime(
        page: Int,
        query: String,
        filters: FilterList,
    ): Observable<AnimesPage> {
        return Observable.defer {
            try {
                client.newCall(this.searchAnimeRequest(page, query, filters)).asObservableSuccess()
            } catch (e: NoClassDefFoundError) {
                // RxJava doesn't handle Errors, which tends to happen during global searches
                // if an old extension using non-existent classes is still around
                throw RuntimeException(e)
            }
        }
            .map { response ->
                this.searchAnimeParse(response)
            }
    }

    /**
     * Returns the request for the search anime given the page.
     *
     * @param page the page number to retrieve.
     * @param query the search query.
     * @param filters the list of filters to apply.
     */
    protected open fun searchAnimeRequest(
        page: Int,
        query: String,
        filters: FilterList,
    ): Request = throw UnsupportedOperationException("Unsupported!")

    /**
     * Parses the response from the site and returns a [AnimesPage] object.
     *
     * @param response the response from the site.
     */
    protected open fun searchAnimeParse(response: Response): AnimesPage = throw UnsupportedOperationException("Unsupported!")

    /**
     * Get a page with a list of latest anime updates.
     * Normally it's not needed to override this method.
     *
     * @since extensions-lib 1.5
     * @param page the page number to retrieve.
     */
    override suspend fun getLatestUpdates(page: Int): AnimesPage {
        @Suppress("DEPRECATION")
        return fetchLatestUpdates(page).awaitSingle()
    }

    /**
     * Returns an observable containing a page with a list of latest anime updates.
     * Normally it's not needed to override this method.
     *
     * @param page the page number to retrieve.
     */
    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getLatestUpdates(page)"))
    open fun fetchLatestUpdates(page: Int): Observable<AnimesPage> {
        return client.newCall(latestUpdatesRequest(page))
            .asObservableSuccess()
            .map { response ->
                latestUpdatesParse(response)
            }
    }

    /**
     * Returns the request for latest anime given the page.
     *
     * @param page the page number to retrieve.
     */
    /* SY --> protected <-- SY */
    abstract fun latestUpdatesRequest(page: Int): Request

    /**
     * Parses the response from the site and returns a [AnimesPage] object.
     *
     * @param response the response from the site.
     */
    /* SY --> protected <-- SY */
    abstract fun latestUpdatesParse(response: Response): AnimesPage

    /**
     * Get the updated details for a anime.
     * Normally it's not needed to override this method.
     *
     * @since extensions-lib 1.4
     * @param anime the anime to update.
     * @return the updated anime.
     */
    override suspend fun getAnimeDetails(anime: SAnime): SAnime {
        @Suppress("DEPRECATION")
        return this.fetchAnimeDetails(anime).awaitSingle()
    }

    /**
     * Returns an observable with the updated details for a anime.
     * Normally it's not needed to override this method.
     *
     * @param anime the anime to be updated.
     */
    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getAnimeDetails(anime)"))
    open fun fetchAnimeDetails(anime: SAnime): Observable<SAnime> {
        return client.newCall(this.animeDetailsRequest(anime))
            .asObservableSuccess()
            .map { response ->
                this.animeDetailsParse(response).apply { initialized = true }
            }
    }

    /**
     * Returns the request for the details of a anime. Override only if it's needed to change the
     * url, send different headers or request method like POST.
     * Normally it's not needed to override this method.
     *
     * @param anime the anime to be updated.
     */
    open fun animeDetailsRequest(anime: SAnime): Request {
        return GET(baseUrl + anime.url, headers)
    }

    /**
     * Parses the response from the site and returns the details of a anime.
     *
     * @param response the response from the site.
     */
    protected open fun animeDetailsParse(response: Response): SAnime = throw UnsupportedOperationException("Unsupported!")

    // KMK -->
    /**
     * Whether parsing related animes in anime page or extension provide custom related animes request.
     *
     * @default true
     * @since komikku/extensions-lib 1.6
     */
    override val supportsRelatedAnimes: Boolean get() = true

    /**
     * Fetch related animes for a anime from source/site.
     * Normally it's not needed to override this method.
     *
     * @since komikku/extensions-lib 1.6
     * @param anime the current anime to get related animes.
     * @return the related animes for the current anime.
     * @throws UnsupportedOperationException if a source doesn't support related animes.
     */
    override suspend fun fetchRelatedAnimeList(anime: SAnime): List<SAnime> = coroutineScope {
        async {
            client.newCall(this@HttpSource.relatedAnimeListRequest(anime))
                .execute()
                .let { response ->
                    this@HttpSource.relatedAnimeListParse(response)
                }
        }.await()
    }

    /**
     * Returns the request for get related anime list. Override only if it's needed to override
     * the url, send different headers or request method like POST.
     * Normally it's not needed to override this method.
     *
     * @since komikku/extensions-lib 1.6
     * @param anime the anime to look for related animes.
     */
    protected open fun relatedAnimeListRequest(anime: SAnime): Request {
        return this.animeDetailsRequest(anime)
    }

    /**
     * Parses the response from the site and returns a list of related animes.
     *
     * @since komikku/extensions-lib 1.6
     * @param response the response from the site.
     */
    protected open fun relatedAnimeListParse(response: Response): List<SAnime> = this.popularAnimeParse(response).animes
    // KMK <--

    /**
     * Get all the available episodes for a anime.
     * Normally it's not needed to override this method.
     *
     * @param anime the anime to update.
     * @return the episodes for the anime.
     */
    override suspend fun getEpisodeList(anime: SAnime): List<SEpisode> {
        @Suppress("DEPRECATION")
        return this.fetchEpisodeList(anime).awaitSingle()
    }

    /**
     * Returns an observable with the updated episode list for a anime.
     * Normally it's not needed to override this method.
     *
     * @param anime the anime to look for episodes.
     */
    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getEpisodeList(anime)"))
    open fun fetchEpisodeList(anime: SAnime): Observable<List<SEpisode>> {
        return client.newCall(this.episodeListRequest(anime))
            .asObservableSuccess()
            .map { response ->
                this.episodeListParse(response)
            }
    }

    /**
     * Returns the request for updating the episode list. Override only if it's needed to override
     * the url, send different headers or request method like POST.
     * Normally it's not needed to override this method.
     *
     * @param anime the anime to look for episodes.
     */
    protected open fun episodeListRequest(anime: SAnime): Request {
        return GET(baseUrl + anime.url, headers)
    }

    /**
     * Parses the response from the site and returns a list of episodes.
     *
     * @param response the response from the site.
     */
    protected open fun episodeListParse(response: Response): List<SEpisode> = throw UnsupportedOperationException("Unsupported!")

    /**
     * Parses the response from the site and returns a SEpisode Object.
     *
     * @param response the response from the site.
     */
    protected open fun episodePageParse(response: Response): SEpisode = throw UnsupportedOperationException("Not used!")

    /**
     * Get the list of videos a episode has. Videos should be returned
     * in the expected order; the index is ignored.
     * Normally it's not needed to override this method.
     *
     * @param episode the episode.
     * @return the videos for the episode.
     */
    override suspend fun getVideoList(episode: SEpisode): List<Video> {
        @Suppress("DEPRECATION")
        return this.fetchVideoList(episode).awaitSingle()
    }

    /**
     * Returns an observable with the video list for a episode.
     * Normally it's not needed to override this method.
     *
     * @param episode the episode whose video list has to be fetched.
     */
    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getVideoList(episode)"))
    open fun fetchVideoList(episode: SEpisode): Observable<List<Video>> {
        return client.newCall(videoListRequest(episode))
            .asObservableSuccess()
            .map { response ->
                this.videoListParse(response)
            }
    }

    /**
     * Returns the request for getting the video list. Override only if it's needed to override the
     * url, send different headers or request method like POST.
     * Normally it's not needed to override this method.
     *
     * @param episode the episode whose video list has to be fetched.
     */
    protected open fun videoListRequest(episode: SEpisode): Request = pageListRequest(episode)
    protected open fun pageListRequest(episode: SEpisode): Request {
        return GET(baseUrl + episode.url, headers)
    }

    /**
     * Parses the response from the site and returns a list of videos.
     *
     * @param response the response from the site.
     */
    protected open fun videoListParse(response: Response): List<Video> = throw UnsupportedOperationException("Unsupported!")

    /**
     * Returns the source url of the image.
     * Normally it's not needed to override this method.
     *
     * @since extensions-lib 1.5
     * @param video the video whose source image has to be fetched.
     */
    @Suppress("DEPRECATION")
    open suspend fun getVideoUrl(video: Video): String {
        return this.fetchVideoUrl(video).awaitSingle()
    }

    /**
     * Returns an observable with the video containing the source url of the image. If there's any
     * error, it will return null instead of throwing an exception.
     * Normally it's not needed to override this method.
     *
     * @param video the video whose source URL has to be fetched.
     */
    @Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getVideoUrl(video)"))
    open fun fetchVideoUrl(video: Video): Observable<String> {
        return client.newCall(this.videoUrlRequest(video))
            .asObservableSuccess()
            .map { videoUrlParse(it) }
    }

    /**
     * Returns the request for getting the url to the source video. Override only if it's needed to
     * override the url, send different headers or request method like POST.
     * Normally it's not needed to override this method.
     *
     * @param video the video whose source URL has to be fetched
     */
    protected open fun videoUrlRequest(video: Video): Request {
        return GET(video.url, headers)
    }

    /**
     * Parses the response from the site and returns the absolute url to the source image.
     *
     * @param response the response from the site.
     */
    protected open fun videoUrlParse(response: Response): String = imageUrlParse(response)
    protected open fun imageUrlParse(response: Response): String = throw UnsupportedOperationException()

    /**
     * Returns the response of the source video.
     * Normally it's not needed to override this method.
     *
     * @since extensions-lib 1.5
     * @param video the video whose source URL has to be downloaded.
     */
    open suspend fun getVideo(video: Video): Response = getImage(video)
    open suspend fun getImage(video: Video): Response {
        return client.newCachelessCallWithProgress(videoRequest(video), video)
            .awaitSuccess()
    }

    /**
     * Returns the request for getting the source video. Override only if it's needed to override
     * the url, send different headers or request method like POST.
     * Normally it's not needed to override this method.
     *
     * @param video the video whose URL has to be fetched
     */
    protected open fun videoRequest(video: Video): Request = imageRequest(video)
    protected open fun imageRequest(video: Video): Request {
        return GET(video.videoUrl!!, headers)
    }

    /**
     * Assigns the url of the episode without the scheme and domain. It saves some redundancy from
     * database and the urls could still work after a domain change.
     * Normally it's not needed to override this method.
     *
     * @param url the full url to the episode.
     */
    fun SEpisode.setUrlWithoutDomain(url: String) {
        this.url = getUrlWithoutDomain(url)
    }

    /**
     * Assigns the url of the anime without the scheme and domain. It saves some redundancy from
     * database and the urls could still work after a domain change.
     * Normally it's not needed to override this method.
     *
     * @param url the full url to the anime.
     */
    fun SAnime.setUrlWithoutDomain(url: String) {
        this.url = getUrlWithoutDomain(url)
    }

    /**
     * Returns the url of the given string without the scheme and domain.
     * Normally it's not needed to override this method.
     *
     * @param orig the full url.
     */
    private fun getUrlWithoutDomain(orig: String): String {
        return try {
            val uri = URI(orig.replace(" ", "%20"))
            var out = uri.path
            if (uri.query != null) {
                out += "?" + uri.query
            }
            if (uri.fragment != null) {
                out += "#" + uri.fragment
            }
            out
        } catch (e: URISyntaxException) {
            orig
        }
    }

    /**
     * Returns the url of the provided anime.
     * Normally it's not needed to override this method.
     *
     * @since extensions-lib 1.4
     * @param anime the anime
     * @return url of the anime
     */
    open fun getAnimeUrl(anime: SAnime): String {
        return this.animeDetailsRequest(anime).url.toString()
    }

    /**
     * Returns the url of the provided episode.
     * Normally it's not needed to override this method.
     *
     * @since extensions-lib 1.4
     * @param episode the episode
     * @return url of the episode
     */
    open fun getEpisodeUrl(episode: SEpisode): String {
        return videoListRequest(episode).url.toString()
    }

    /**
     * Called before inserting a new episode into database. Use it if you need to override episode
     * fields, like the title or the episode number. Do not change anything to [anime].
     *
     * @param episode the episode to be added.
     * @param anime the anime of the episode.
     */
    open fun prepareNewEpisode(episode: SEpisode, anime: SAnime) {}

    /**
     * Returns the list of filters for the source.
     */
    override fun getFilterList() = FilterList()
}
